"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContentType = exports.getComponentConfigs = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const node_os_1 = tslib_1.__importDefault(require("node:os"));
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const fs = tslib_1.__importStar(require("fs-extra"));
const mimeTypes = tslib_1.__importStar(require("mime-types"));
const constants_1 = require("./constants");
const generate_component_types_1 = require("./generate-component-types");
const validation_1 = require("./validation");
const compileTypeScript = (inputFilePath, outputDir) => {
    return new Promise((resolve, reject) => {
        try {
            const tscPath = require.resolve("typescript/bin/tsc");
            if (tscPath) {
                (0, child_process_1.execFile)("node", [
                    tscPath,
                    node_path_1.default.resolve(inputFilePath),
                    "--outDir",
                    outputDir,
                    "--jsx",
                    "react-jsx",
                    "--target",
                    "es2019",
                    "--esModuleInterop",
                    "true",
                    "--moduleResolution",
                    "node",
                    "--module",
                    "commonjs",
                    "--strict",
                    "true",
                    "--skipLibCheck",
                    "true",
                ], (error, stdout, stderr) => {
                    if (error) {
                        // Print any Typescript output to the user, such as errors
                        console.log(stdout);
                        reject(`Compilation failed: ${error.message}`);
                        return;
                    }
                    if (stderr) {
                        reject(`Error during compilation: ${stderr}`);
                        return;
                    }
                    resolve("Compilation successful!");
                });
            }
        }
        catch (e) {
            reject(new Error("Could not find TypeScript, please install it globally (npm install -g typescript)"));
        }
    });
};
async function getFolderPaths() {
    try {
        const folderPaths = await fs.readdir(constants_1.CUSTOM_COMPONENTS_PATH, {
            withFileTypes: true,
        });
        // filter out any non-directory items
        const directories = folderPaths.filter((dirent) => dirent.isDirectory() ||
            (dirent.isSymbolicLink() &&
                fs
                    .statSync(node_path_1.default.join(constants_1.CUSTOM_COMPONENTS_PATH, dirent.name))
                    .isDirectory()));
        // map each directory to its path
        const folderPathsArray = directories.map((dirent) => node_path_1.default.join(constants_1.CUSTOM_COMPONENTS_PATH, dirent.name));
        return folderPathsArray;
    }
    catch {
        throw new Error("Could not access component directory, check your permissions");
    }
}
async function getComponentConfigs(generateTypesFiles) {
    const folderPaths = await getFolderPaths();
    let hasError = false;
    const promiseConfigFiles = folderPaths.map(async (ccpath) => {
        const absPath = node_path_1.default.resolve(ccpath);
        try {
            const config = await fs.readJSON(`${absPath}/config.json`);
            console.log(`Found component in ${absPath}`);
            return { ccpath, config };
        }
        catch (e) {
            // Noop because there is a fallback
        }
        try {
            // This is a tad complex to explain this hack but here's the context:
            // We want to be able to hot reload the config.ts file, but we can't import it directly
            // because it is going to get cached in the module cache and we dont have access to it to clear it
            // so instead we copy the file to a new location with a random name and import that
            // this is technically a memory leak, but you shouldnt really have a hot module server running forever
            const rawPath = `${ccpath}/config.ts`;
            const fileName = node_path_1.default.resolve(rawPath);
            const outputDirectory = node_path_1.default.resolve(`${node_os_1.default.tmpdir()}/superblocks/${ccpath}/config.timestamp-${Date.now()}-${Math.random()
                .toString(16)
                .slice(2)}`);
            await fs.ensureDir(outputDirectory);
            await compileTypeScript(fileName, outputDirectory);
            console.log(`Typescript compiled to ${ccpath}`);
            const config = (await Promise.resolve(`${outputDirectory + "/config.js"}`).then(s => tslib_1.__importStar(require(s)))).default;
            const isValid = (0, validation_1.validateCustomComponents)(config);
            if (!isValid.valid) {
                // Not throwing because we don't need a stack trace here
                console.log(`Invalid config.ts file found`);
                console.log(isValid.message);
                hasError = true;
            }
            return { ccpath, config };
        }
        catch (e) {
            console.error(e);
            console.error(e.message);
            throw e;
        }
    });
    const configFiles = await Promise.all(promiseConfigFiles);
    if (generateTypesFiles) {
        for (const { config, ccpath } of configFiles) {
            const typesFileContents = (0, generate_component_types_1.generateComponentTypesFile)(config);
            await fs.writeFile(`${ccpath}/types.ts`, typesFileContents);
            console.log(`Generated ${ccpath}/types.ts`);
        }
    }
    const configs = configFiles
        .filter((component) => component.config !== null)
        .reduce((acc, { config }) => {
        acc[config.id] = config;
        return acc;
    }, {});
    return {
        configs,
        hasError,
    };
}
exports.getComponentConfigs = getComponentConfigs;
const getContentType = (filename) => {
    const mimeType = mimeTypes.lookup(filename);
    if (!mimeType) {
        return "";
    }
    return mimeType;
};
exports.getContentType = getContentType;
