import { execFile } from "child_process";
import os from "node:os";
import path from "node:path";
import * as fs from "fs-extra";
import * as mimeTypes from "mime-types";
import { CUSTOM_COMPONENTS_PATH } from "./constants";
import { generateComponentTypesFile } from "./generate-component-types";
import { validateCustomComponents } from "./validation";

const compileTypeScript = (inputFilePath: string, outputDir: string) => {
  return new Promise((resolve, reject) => {
    try {
      const tscPath = require.resolve("typescript/bin/tsc");
      if (tscPath) {
        execFile(
          "node",
          [
            tscPath,
            path.resolve(inputFilePath),
            "--outDir",
            outputDir,
            "--jsx",
            "react-jsx",
            "--target",
            "es2019",
            "--esModuleInterop",
            "true",
            "--moduleResolution",
            "node",
            "--module",
            "commonjs",
            "--strict",
            "true",
            "--skipLibCheck",
            "true",
          ],
          (error, stdout, stderr) => {
            if (error) {
              // Print any Typescript output to the user, such as errors
              console.log(stdout);
              reject(`Compilation failed: ${error.message}`);
              return;
            }
            if (stderr) {
              reject(`Error during compilation: ${stderr}`);
              return;
            }
            resolve("Compilation successful!");
          }
        );
      }
    } catch (e) {
      reject(
        new Error(
          "Could not find TypeScript, please install it globally (npm install -g typescript)"
        )
      );
    }
  });
};

async function getFolderPaths() {
  try {
    const folderPaths = await fs.readdir(CUSTOM_COMPONENTS_PATH, {
      withFileTypes: true,
    });
    // filter out any non-directory items
    const directories = folderPaths.filter(
      (dirent) =>
        dirent.isDirectory() ||
        (dirent.isSymbolicLink() &&
          fs
            .statSync(path.join(CUSTOM_COMPONENTS_PATH, dirent.name))
            .isDirectory())
    );
    // map each directory to its path
    const folderPathsArray = directories.map((dirent) =>
      path.join(CUSTOM_COMPONENTS_PATH, dirent.name)
    );
    return folderPathsArray;
  } catch {
    throw new Error(
      "Could not access component directory, check your permissions"
    );
  }
}

export async function getComponentConfigs(
  generateTypesFiles: boolean
): Promise<{
  configs: Record<string, any>;
  hasError: boolean;
}> {
  const folderPaths = await getFolderPaths();
  let hasError = false;
  const promiseConfigFiles = folderPaths.map(async (ccpath) => {
    const absPath = path.resolve(ccpath);
    try {
      const config = await fs.readJSON(`${absPath}/config.json`);
      console.log(`Found component in ${absPath}`);
      return { ccpath, config };
    } catch (e: any) {
      // Noop because there is a fallback
    }

    try {
      // This is a tad complex to explain this hack but here's the context:
      // We want to be able to hot reload the config.ts file, but we can't import it directly
      // because it is going to get cached in the module cache and we dont have access to it to clear it
      // so instead we copy the file to a new location with a random name and import that
      // this is technically a memory leak, but you shouldnt really have a hot module server running forever
      const rawPath = `${ccpath}/config.ts`;
      const fileName = path.resolve(rawPath);
      const outputDirectory = path.resolve(
        `${os.tmpdir()}/superblocks/${ccpath}/config.timestamp-${Date.now()}-${Math.random()
          .toString(16)
          .slice(2)}`
      );
      await fs.ensureDir(outputDirectory);
      await compileTypeScript(fileName, outputDirectory);
      console.log(`Typescript compiled to ${ccpath}`);
      const config = (await import(outputDirectory + "/config.js")).default;

      const isValid = validateCustomComponents(config);
      if (!isValid.valid) {
        // Not throwing because we don't need a stack trace here
        console.log(`Invalid config.ts file found`);
        console.log(isValid.message);
        hasError = true;
      }
      return { ccpath, config };
    } catch (e: any) {
      console.error(e);
      console.error(e.message);
      throw e;
    }
  });
  const configFiles = await Promise.all(promiseConfigFiles);
  if (generateTypesFiles) {
    for (const { config, ccpath } of configFiles) {
      const typesFileContents = generateComponentTypesFile(config);
      await fs.writeFile(`${ccpath}/types.ts`, typesFileContents);
      console.log(`Generated ${ccpath}/types.ts`);
    }
  }
  const configs = configFiles
    .filter((component) => component.config !== null)
    .reduce((acc: Record<string, any>, { config }) => {
      acc[config.id] = config;
      return acc;
    }, {});
  return {
    configs,
    hasError,
  };
}

export const getContentType = (filename: string): string => {
  const mimeType = mimeTypes.lookup(filename);
  if (!mimeType) {
    return "";
  }
  return mimeType as string;
};
